<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Raster</title>
	<link rel="stylesheet" href="paperjs-0.22/examples/css/style.css">
	<script type="text/javascript" src="paperjs-0.22/lib/paper.js"></script>
	<script type="text/paperscript" canvas="canvas">
		// Create an object to handle animations
		var animationManager = {
			animations : [],
			
			update : function(dT) {
				// TODO: Major error handling!
				for(var i=0; i<this.animations.length; i++) {
					var _a = this.animations[i];
					var progress =  (new Date().getTime() - _a["startTime"]) / _a["duration"];
					if(progress <= 1) {
						// TODO: Assume linear easing for now
						var newVal = progress * (_a["target"] - _a["startVal"]) + _a["startVal"];
						_a["object"][_a["property"]] = newVal;
						// Assume object has update function
						if(_a["object"].update) _a["object"].update();
					}
					if(progress >= 1) {
						// Call completion method
						_a["complete"]();
					}
				}
			},
			
			stop : function(object) {
				// Stop all pending animations for a given object
				var survivors = [];
				for(var i=0; i<animations.length; i++) {
					if(!(animations[i]["object"] === object)) {
						survivors.push(animations[i]);
					}
				}	
				animations = survivors;
			},
			
			clear : function() {
				animations = [];
				// Probably need to do more to avoid memory leaks?
			},
			
			register : function(object, property, target, duration, easing, complete) {
				// TODO: Default parameters
				var _a = {"object" 	  : object,
						  "property"  : property,
						  "target"	  : target,
						  "duration"  : duration,
						  "easing"	  : easing,
						  "complete"  : complete,
						  "startTime" : new Date().getTime(),
						  "startVal"  : object[property]
						  };
				this.animations.push(_a);
			}
			
		}	
		
		var OrbitItem = window.paper.Layer.extend({
			expanded : false,
			dotScale : 1,
			scaleFactor : 1,
		
			initialize : function(text, radius) {			
				this.base();

				this.basePoint = new Point(0,radius) + view.center;
				this.basePoint = this.basePoint.rotate(Math.random() * 360, view.center);
				//this.activate();
				this.baseDot = new Path.Circle(this.basePoint, 6);
				console.log("Based dot created at: " + this.basePoint);
				this.baseDot.fillColor = 'white';
				this.addChild(this.baseDot);
				
				// Text label
				this.label = new PointText(this.basePoint - new Point(0, 20));
				var words = ["Day", "Ticket", "Mom", "hangover", "loud", "light", "word", "night", "dog", "vote"];
				this.label.content = words[Math.floor(Math.random()*words.length)];
				this.label.characterStyle = {
					font: "Helvetica",
					fontSize : 5,
					fillColor : 'white'
				}
				this.label.fontWeight = "bold";
				this.label.paragraphStyle.justification = 'center';
				this.label.visible = true;
				this.addChild(this.label);
				
				//this.opacity = 0.5;
			},
			
			update : function() {
				this.baseDot.scale(this.dotScale / this.scaleFactor);
				//this.baseDot.scale(1);
				this.scaleFactor *= this.dotScale / this.scaleFactor;
			},
			
			mouseOver : function() {
				//this.baseDot.scale(2);
				//this.scaleFactor *= 2;
				this.expanded = true;
				//this.label.visible = true;
				//animationManager.register(this, "opacity", 1, 300, "linear", function() {}, function() {});
				animationManager.register(this, "dotScale", 2, 300, "linear", function() {});
				animationManager.register(this.label.characterStyle, "fontSize", 20, 300, "linear", function() {});
				console.log(this);
			},
			mouseOut : function() {
				//this.baseDot.scale(1/this.scaleFactor);
				//this.scaleFactor /= this.scaleFactor;
				this.expanded = false;
				//this.label.visible = false;
				//animationManager.register(this, "opacity", 0.5, 600, "linear", function() {});
				animationManager.register(this, "dotScale", 1, 300, "linear", function() {});
				animationManager.register(this.label.characterStyle, "fontSize", 5, 300, "linear", function() {});
			}
		});
	
		var GUIManager = {
			hovering : null,
			clicking : null,
			dragging : null,
			dragStart : null,
			focus : null	
		};
		
		var frame = 1;
		
		var centerLayer = new Layer();
		centerLayer.activate();
		
		var profile = new Raster('profile');
		profile.position = view.center;
		profile.scale(0.4);
		profile.opacity = 1;
		profile.scaleFactor = 1;
		
		var centerCircle = new Path.Circle(view.center, 60);
		centerCircle.strokeColor = 'rgb(251,191,205)';
		centerCircle.strokeWidth = 4;
		centerCircle.clipMask = true;
		
		centerLayer.opacity = 0.999; // Workaround to stop mask from clipping everything
		
		var outerLayer = new Layer();
		outerLayer.activate();
		
		// Use a group to style similar objects together
		var circlesGroup = new Group();
		var outerCircle = new Path.Circle(view.center, 400);
		var c1 = new Path.Circle(view.center, 380);
		var c2 = new Path.Circle(view.center, 310);
		var c3 = new Path.Circle(view.center, 260);
		var c4 = new Path.Circle(view.center, 255);
		var c5 = new Path.Circle(view.center, 250);
		
		var l1 = new Path.Line(new Point(view.center.x - 260, view.center.y), new Point(view.center.x-260, view.size.height));
		var l2 = new Path.Line(new Point(view.center.x - 255, view.center.y), new Point(view.center.x-255, view.size.height));
		var l3 = new Path.Line(new Point(view.center.x - 250, view.center.y), new Point(view.center.x-250, view.size.height));				
		
		circlesGroup.addChildren([outerCircle, c1, c2, c3, c4, c5, l1, l2, l3]);
		circlesGroup.strokeColor = 'rgb(251,191,205)';
		circlesGroup.strokeWidth = 1.5;
		outerCircle.strokeWidth = 20;	// Must set after group to override
		
		
		var linesLayer = new Layer();
		linesLayer.activate();
		for(var i=0; i<12; i++) {
			var _l = new Path.Line(view.center + new Point(0,390), view.center + new Point(0,410));
			_l.strokeColor = 'black';
			_l.strokeWidth = 5;
			_l.rotate(i/12 * 360, view.center);
		}
		
		
		var connectionsLayer = new Layer();
		connectionsLayer.activate();
		// Generate some along the inner circle and connect them randomly
		var n_points = Math.floor(Math.random() * 16 + 6);
		var n_lines = n_points * 2;
		var pointsList = [];
		for(var i=0; i<n_points; i++) {
			// Choose random orbit level
			var _d = Math.floor(Math.random() * 3) * 5;
			var _o = new OrbitItem("asdf", 250 + _d);
			pointsList.push(_o.basePoint);
			connectionsLayer.addChild(_o);
		}

		connectionsLayer.activate();
		for(var i=0; i<n_lines; i++) {
			var i1 = Math.floor(Math.random() * n_points);
			var i2 = Math.floor(Math.random() * n_points);
			var _l = new Path.Line(pointsList[i1], pointsList[i2]);
			//console.log(i1 + ": " + pointsList[i1] + ", " + i2 + ": " + pointsList[i2]);
			_l.strokeColor = 'rgb(251,191,205)';
			_l.opacity = 0.8;
		}
		console.log(n_points + ", " + n_lines);
		
		console.log("Moved? " + centerLayer.moveAbove(connectionsLayer));
		
		function onFrame(event) {
			animationManager.update(event.delta);
			
			//connectionsLayer.rotate(event.delta, view.center);
			
			var desiredScale = Math.cos(frame/10)*0.02 + 1;
			var _s = desiredScale / profile.scaleFactor;
			profile.scale(_s); profile.scaleFactor *= _s;
			
			frame++;
			
			//profile.rotate(event.delta);
			//centerCircle.scale(1.01);
		//	var scale = (Math.sin(event.time * 2) + 1) / 2;
		//	raster.scale(scale / lastScale);
		//	lastScale = scale;
		//	raster.position = center + [Math.sin(event.time * 3) * 256, Math.sin(event.time * 2.5) * 256];
		//	raster.rotate(event.delta * 120);
		}
		
		var hitOptions = {
			segments: false,
			stroke: false,
			fill: true,
			tolerance: 5
		};
		
		function onMouseMove(event) {
			if(!GUIManager.dragging) {
			    var hitResult = project.hitTest(event.point, hitOptions);
			    if (hitResult && hitResult.item) { 	
			    	// It's a hit!
			    	var alreadyHovering = GUIManager.hovering;

					var hoveringResponder = hitResult.item;
					while(!hoveringResponder.mouseOver && hoveringResponder.parent) hoveringResponder = hoveringResponder.parent;	
					
			    	var changeHover = GUIManager.hovering && !(GUIManager.hovering === hoveringResponder);		
					if(!alreadyHovering || changeHover) {
						if(changeHover) {
							// Trigger mouseOut
							// Walk up scene graph until something responds to mouseOut
							var item = GUIManager.hovering;
							while(!item.mouseOut && item.parent) item = item.parent;
							if(item.mouseOut) item.mouseOut(event);
							GUIManager.hovering = null;
							console.log("CHANGE HOVER -- Called mouseOut() on " + item);
						}
						// Trigger mouseOver
						// Walk up scene graph until something responds to mouseOver
						var item = hitResult.item;
						while(!item.mouseOver && item.parent) item = item.parent;	
						if(item.mouseOver) item.mouseOver(event);
						GUIManager.hovering = item;
						console.log("Called mouseOver() on " + item);
					}
				}
				else {
					if(GUIManager.hovering) {
						// Trigger mouseOut
						var item = GUIManager.hovering;
						while(!item.mouseOut && item.parent) item = item.parent;
						if(item.mouseOut) item.mouseOut(event);		
						GUIManager.hovering = null;		
						console.log("Called mouseOut() on " + item);	
					}
				}
			}
		}
		function onMouseDown(event) {
		}
		function onMouseUp(event) {
		}
		function onMouseDrag(event) {
		}

	</script>
</head>
<body>
	<canvas id="canvas" style="background-color: black" resize></canvas>
	<img src="profile.jpg" id="profile" style="display: none;" />
</body>
</html>